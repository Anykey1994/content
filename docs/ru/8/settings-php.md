---
id: settings-php
title: settings.php — настройки окружения сайта
core: 8
metatags:
  title: 'Drupal 8: settings.php — настройки окружения сайта'
  description: 'Обзор возможных настроек окружения сайта.'
---

**settings.php** — файл с настройками для конкретного сайта. Данный сайт содержит специфичные настройки для конкретного сайта.

В данном файле настраиваются такие параметры как подключение к базе данных, пути до конфигураций, соль и т.д. Он может быть использован сторонними модулями для управления собственным поведением, для этого присутствует соответствующий API.

Настройки, в отличие от конфигураций, предназначены только для хранения read-only значений, которые необходимы на очень ранних этапах запуска ядра. Иными словами, это настройки, которые определяют значения для текущего окружения.

Файл является read-only и Drupal регулярно проверяет что данный файл защищён от записи. Прежде чем вносить правки в данный файл на действующем сайте, убедитесь что у вашего пользователя есть права на его запись.

## Где находится settings.php?

Чаще всего вы можете обнаружить данный сайт по пути `/sites/default`, но это зависит от того, как произведена настройка Drupal и какой подход в разработке был использован.

По умолчанию проверяется только `/sites/default`, но если вы настроите мультисайтинг (присутствует `/sites/sites.php`), то поиск будет происходит по различным директориям.

Рассмотрим на примере. Если Drupal установлен по пути `https://www.drupal.org:8080/mysite/test/` то файл **settings.php** будет искаться в следующих директориях, в порядке приоритета:

- sites/8080.www.drupal.org.mysite.test
- sites/www.drupal.org.mysite.test
- sites/drupal.org.mysite.test
- sites/org.mysite.test
- sites/8080.www.drupal.org.mysite
- sites/www.drupal.org.mysite
- sites/drupal.org.mysite
- sites/org.mysite
- sites/8080.www.drupal.org
- sites/www.drupal.org
- sites/drupal.org
- sites/org
- sites/default

## Программное получение настроек

В Drupal присутствует специальный утилитарный объект `\Drupal\Core\Site\Settings`. При помощи данного объекта вы можете получать актуальные настройки которые используются для текущего запроса.

### get()

Возвращает значение конкретной настройки, принимает два аргумента:

- `$name`: Название настройки значение которой необходимо получить.
- `$default = NULL`: (опционально) Значение по умолчанию, если оно не найдено в файле.

Данный метод вызовет ошибку если вы захотите получить значение для `install_profile`. Если вы хотите получить название инсталяционного профиля используйте [сервис](services/services.md) `install_profile`.

**Пример:**

```php
$batch_size = Settings::get('entity_update_batch_size', 50);
```

### getAll()

Возвращает все настройки и предназначен только для тестирования.

```php
$settings = Settings::getAll();
```

### getHashSalt()

Возвращает значение настройки `hash_salt`. Если данной настройки нет или она является пустой, то вызывается исключение.

```php
$salt = Settings::getHashSalt();
```

## Структура settings.php

### $config_directories

> [!NOTE]
> Данная настройка признана устаревшей, вместо неё необходимо указывать `$settings['config_sync_directory']`. Для более подробной информации изучите соответствующее изменения [Drupal 8.8.0](releases/release-8.8.0.md).

Массив `$config_directories` задаёт пути в файловой систему до путей где необходимо хранить конфигурации. В процессе [установки Drupal](installation.md) создаётся директория `sync`, которая используется для импортирования конфигураций. Также может быть указана `active` директория для хранения актуальных конфигураций. По умолчанию `active` не задаётся, так как эта информация хранится в БД.

Данная настройка автоматически задаётся и добавляется в конец файла в процессе установки.

**Пример**:

```php
$config_directories = [
  CONFIG_SYNC_DIRECTORY => '/directory/outside/webroot',
];
```

### $settings

#### Соль

[Соль](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BB%D1%8C_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)) используемая для генерации одноразовых ссылок, токенов форм, ссылок отписки и т.д.

Значение для данной переменной задаётся случайной генерацией в процессе установки. Если вы поменяете это значение на рабочем сайте, то все ссылки одноразового входа будут инвалидированы.

> [!NOTE] 
> Если вы размещаете один сайт на кластере серверов, убедитесь что у всех одинаковая соль, чтобы поведение было идентичным независимо от активного сервера.

Для более продвинутой защиты вы можете вынести значение соли за пределы Drupal и запрашивать его из файла или иных мест. Вы также должны убедиться что данный файл не попадает в бэкапы сайта и не хранится в БД.

**Пример:**

```php
$settings['hash_salt'] = file_get_contents('/home/example/salt.txt');
```

#### Идентификатор деплоя

Контейнер Drupal для [Dependency Injection](services/dependency-injection.md) автоматически инвалидируется и перестраивается при изменении версии ядра. Когда обновляете контриб или кастом модули которые меняют контейнер, изменение данного идентификатора также инвалидирует и перестроит контейнер как только код будет задеплоен.

**Пример:**

```php
$settings['deployment_identifier'] = \Drupal::VERSION;
```

#### Контроль доступа для update.php

Когда вы обновляете Drupal при помощи `/update.php` производится проверка на наличие прав доступа «Управление обновлениями» (`administer software updates`) у пользователя. Если у пользователя нету данных прав, то обновление не будет запущено.

Благодаря этой настройке вы можете временно отключить данную проверку, если по каким-то причинам у вас нет возможности авторизоваться под соответствующим пользователем или пользователя с такими правами не существует.

Значение `TRUE` — пропускает проверку прав, `FALSE` (по умолчанию) — будет проверять права доступа.

> [!IMPORTANT]
> Не забудьте включить проверку прав доступа после успешного запуска.

> [!TIP]
> Вы можете использовать [Drush](../drush.md) команду `drush updb` для применения обновлений из терминала.

**Пример:**

```php
$settings['update_free_access'] = FALSE;
```

#### Прокси

Если сайту необходимо обращаться во внешний интернет через прокси, вы можете указать соответствующие настройки.

Для различных запросов может использоваться различный прокси. Для этого имеется три настройки:

- `$settings['http_client_config']['proxy']['http']` — для проксирования запросов с HTTP.
- `$settings['http_client_config']['proxy']['https']` — для проксирования запросов с HTTPS.
- `$settings['http_client_config']['proxy']['no']` — массив из доверенных хостов, запросы к которым будут идти напрямую, без использования прокси.

**Пример:**

```php
$settings['http_client_config']['proxy']['http'] = 'http://proxy_user:proxy_pass@example.com:8080';
$settings['http_client_config']['proxy']['https'] = 'http://proxy_user:proxy_pass@example.com:8080';
$settings['http_client_config']['proxy']['no'] = ['127.0.0.1', 'localhost'];
```

#### Обратный прокси

Обратные прокси часто используются для улучшения производительности высоконагруженных сайтов и также могут предоставить новые способы кэширования, безопасности и шифрования. В окружении где Drupal находится за обратным прокси, должен быть получен реальный IP адрес клиента для корректной работы различных подсистем, таких как логирование, статистика и управление доступом. В самом простом сценарии прокси сервер добавляет заголовок `X-Forwarded-For` в запрос, который содержит IP адрес клиента. Тем не менее HTTP заголовки уязвимы к спуфингу, что позволяет получить доступ к заголовку `X-Forwarded-For`. Следовательно, Drupal требует указывать адреса всех удалённых прокси для корректной работы.

Включение данной настройки позволяет корректно определять IP адрес клиента. Если ваш сайт работает на шаред хостинге или не имеет обратного прокси, данные настройки должны быть закомментированы (по умолчанию).

Для того чтобы данная настройка работала вы должны указать все возможные IP адреса обратных прокси в `reverse_proxy_addresses`. Если полный список адресов не доступен в вашем окружении (например, вы используете CDN) вы можете указать `$_SERVER['REMOTE_ADDR']` прямо в настройках. Но будьте аккуратны, это открывает возможности для спуфинга если вы не предпримите дополнительных мер предодсторожности.

Вы также можете настроить доверенные HTTP заголовки для обратного прокси. Общие значения:

- `\Symfony\Component\HttpFoundation\Request::HEADER_X_FORWARDED_ALL`
- `\Symfony\Component\HttpFoundation\Request::HEADER_FORWARDED`

Имейте в виду что значение по умолчанию `\Symfony\Component\HttpFoundation\Request::HEADER_X_FORWARDED_ALL | \Symfony\Component\HttpFoundation\Request::HEADER_FORWARDED` небезопасно. Вы должны указать только те заголовки, которые используются обратным прокси.

Например `\Symfony\Component\HttpFoundation\Request::HEADER_X_FORWARDED_ALL` будет считать доверенными следующие заголовки: `X-Forwarded-For`, `X-Forwarded-Host`, `X-Forwarded-Proto`, `X-Forwarded-Port`.

**Пример:**

```php
$settings['reverse_proxy_trusted_headers'] = \Symfony\Component\HttpFoundation\Request::HEADER_X_FORWARDED_ALL | \Symfony\Component\HttpFoundation\Request::HEADER_FORWARDED;
```

#### Vary: Cookie

По умолчанию Drupal отправляет HTTP заголовок «Vary: Cookie» для всех анонимных пользователей. Это говорит HTTP прокси что он может возвращать результат страницы из своего локального кэша без обращения к веб-серверу если пользователь обращается с тем же заголовком Cookie как оригинальный запрос.

Без использования «Vary: Cookie», авторизованные пользователи также будут получать результат из анонимного кэша. Если сайт по большей части статичен и предназначен для анонимных пользователей, за исключением заранее известных редакторов и администраторов, то данный заголовок можно опустить.

Данное поведение позволяет организовать более продвинутое кэширование на стороне прокси и обратного прокси. Например, если пользователи будут слать разные куки файлы, они всеравно будут получать содержимое из кэша. Тем не менее, авторизованные пользователи должны обращаться к сайту напрямую (в обход прокси и обратного прокси) для того чтобы не получать результаты страниц из кэша прокси.

**Пример:**

```php
$settings['omit_vary_cookie'] = TRUE;
```

#### TTL кэша для ответов 4xx

Элементы кэша которые хранятся на основе URL приводят к увеличению общего числа кэш элементов. Данное поведение может стать проблемой на 404 страницах, которых может быть очень много. Для данных страницы вы можете задать свой собственный TTL (Time To Live) в секундах. По умолчанию это значение равняется одному часу (3600 секунд). Для того чтобы отключить кэширование 4хх ответов, нужно задать значение 0.

> [!NOTE]
> Данное значение используется в ядре только модулем page_cache. Если данный модуль отключен, это значение не будет влиять ни на что.

**Пример:**

```php
$settings['cache_ttl_4xx'] = 3600;
```

#### Время жизни кэша форм

[Form API](forms/forms.md) Drupal хранит часть информации форм в кэше. По умолчанию время жизни данного кэша 6 часов (21600 секунд). Устаревшие данные удаляются при первом запуске cron.

При помощи данной настройки вы можете задать своё собственное время жизни кэша форм.

**Пример:**

```php
$settings['form_cache_expiration'] = 21600;
```

#### Загрузчик классов

Если для PHP включено расширение APC, то для увеличения производительности используется загрузчик классов Symfony APC. Данное поведение можно отключить при помощи данной опции.

**Пример:**

```php
$settings['class_loader_auto_detect'] = FALSE;
``` 

Если APC расширение не найдно, или оно отключено, то будет использован автозагрузчик [Comoposer](../composer/composer.md), который хорошо подходит для разработки, так как не сломается если код был перемещён в файловой системе. Вы также можете задекорировать базовый загрузчик с любым другим решением, а не только Symfony APC, так как все продакшен сайты должны иметь кэш для загрузчика в том или ином виде.

Для того чтобы задекорировать автозагрузчик, нужно переопределить переменную `$class_loader`.

Пример использования Symfony APC без автоматического обнаружения:

```php
if ($settings['hash_salt']) {
  $prefix = 'drupal.' . hash('sha256', 'drupal.' . $settings['hash_salt']);
  $apc_loader = new \Symfony\Component\ClassLoader\ApcClassLoader($prefix, $class_loader);
  unset($prefix);
  $class_loader->unregister();
  $apc_loader->register();
  $class_loader = $apc_loader;
}
```

#### Разрешение авторизованных операций

Менеджер обновлений (модуль `update`) предоставляет администраторам сайта механизм безопасной установки обновлений для сайта напрямую через веб-интерфейс. На серверах с дополнительной защитой менеджер обновлений потребует предоставить доступы для SSH или FTP прежде чем операция будет выполнена. Это позволяет обновлять файлы сайта от лица пользователя который владеет ими, вместо того чтобы обновлять их под пользователем веб-сервера. На серверах где пользователь веб-сервера также является и владельцем файлов сайта запрос на доступ будет пропущен. Обычно такое поведение применимо для шаред хостингов, где пользователь веб-сервера и владельца сайта находятся в одной группе, что не очень безопасно.

Благодаря данной настройке вы можете отключить это поведение и обновление сайта будет доступно только по SSH и FTP.

> [!NOTE]
> Менеджер обновлений также отвечает за возможность загрузки и установки модулей и тем по URL с drupal.org или загрузке архива. Этот функционал также будет отключен а все его элементы пропадут из интерфейса. При попытке зайти по старым URL будет выдавать ошибка «Вы не авторизованы для доступа к данной странице» даже для главного администратора.

**Пример:**

```php
$settings['allow_authorize_operations'] = FALSE;
```